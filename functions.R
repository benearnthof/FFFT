# low level helper functions for the app
# see the documentation for details
get_hbands <- function(suspensions, simple = TRUE, inspectionmatrix,
                       names = c("hband", "amount", "htotal", "inspi")) {
  # other functions still depend on hbands having a defined length
  if (length(suspensions) == 0 | is.null(suspensions)) {
    ret <- data.frame(matrix(ncol = 4, nrow = 0))
    colnames(ret) <- names
    attributes(ret) <- c(attributes(ret), simple = simple)
    return(ret)
  }
  if (is.data.frame(suspensions)) {
    tmp <- as.vector(t(suspensions))
  } else {
    tmp <- suspensions
  }
  # the simple case, the data frame being already disaggregated
  if (simple) {
    ret <- data.frame(tmp)
    ret$amount <- 1
  } else {
    # the nonsimple case => aggregate suspensions to hour-bands according to the
    # following procedure
    fiftyplus <- tmp[tmp > 50]
    ret <- numeric()
    ret[1:length(tmp[tmp <= 50])] <- 50
    if (!is_empty(fiftyplus)) { # exception handling in case all susps are < 50
      ret[(length(tmp[tmp <= 50]) + 1):length(tmp)] <- round(fiftyplus, digits = -2)
    }
    ret <- plyr::count(ret)
  }
  ret$htotal <- ret[, 1]
  # find out what inspection interval the suspensions are in
  # insmatrix must not have nrow smaller than 1
  ret$inspi <- get_intervals(ret$htotal, inspectionmatrix)
  names(ret) <- names
  attributes(ret) <- c(attributes(ret), simple = simple) # for disaggregation
  return(ret)
}

# added to remove dependency on memisc package
sort.data.frame <- function(x, decreasing = FALSE, by = NULL, na.last = NA, ...) {
  if (!length(by)) {
    ii <- do.call(order, c(x, list(decreasing = decreasing, na.last = na.last)))
  } else if (is.character(by)) {
    ii <- do.call(order, c(x[by], list(decreasing = decreasing, na.last = na.last)))
  } else if (inherits(by, "formula")) {
    bydata <- model.frame(formula = by, data = x, na.action = na.pass)
    bydata <- bydata[rev(all.vars(by))]
    ii <- do.call(order, c(bydata, list(decreasing = decreasing, na.last = na.last)))
  }
  x[ii, ]
}

# plotting microbenchmark results in boxplots
# this on is not an integral part of the app, i just use it for convenience
plt_mbm <- function(mbm, zoom = 1, sci = TRUE) {
  molten <- reshape2::melt(mbm) %>% dplyr::select(-variable)
  plt <- ggplot(molten, aes(x = expr, y = value)) +
    geom_boxplot() +
    coord_cartesian(ylim = (boxplot.stats(molten$value)$stats[c(1, 5)]) * zoom) +
    xlab("Function Calls") +
    ylab(paste("Elapsed Time (in ns)", sep = "")) +
    if (!sci) {
      scale_y_continuous(labels = scales::comma)
    }
  return(plt)
}
# calculating total errors for one month
calc_errors <- function(ndraws, amnt, bnds, bet, tht, efperiod, dist = "weibull", maxlyf) {
  if (dim(bnds)[1] == 0) {
    return(0)
  }
  erroriter <- numeric(length = ndraws)
  avgerrors <- numeric(length = amnt)
  # calculating errors with draws from weibull, normal, or lognormal distribution
  call <- paste0("r", dist)
  for (j in 1:amnt) {
    susp_current <- bnds$hband[j]
    weibull <- do.call(call, list(ndraws, bet, tht))
    erroriter <- as.numeric((susp_current - weibull) > 0)
    total <- sum(erroriter)
    avgerrors[j] <- total / ndraws
  }
  # respecting the errorfreeperiod
  check <- bnds$htotal < efperiod | bnds$htotal > maxlyf
  avgerrors[check] <- 0
  gesamtfehler <- sum(avgerrors)
  return(gesamtfehler)
}

# calculating errors fast & exact (sacrifices randomness through draws)
calc_errors_fast <- function(bnds, bet, tht, efperiod, dist = "weibull", maxlyf) {
  if (dim(bnds)[1] == 0) {
    return(0)
  }
  call <- paste0("p", dist)
  avgerrors <- do.call(call, list(bnds$hband, bet, tht))
  # respecting the errorfreeperiod and maximum life
  check <- bnds$htotal < efperiod | bnds$htotal > maxlyf
  avgerrors[check] <- 0
  gesamtfehler <- sum(avgerrors)
  return(gesamtfehler)
}

# function to return sampling weights larger than 0 for removal of faulty engines
get_dist_weights <- function(bnds, bet, tht, dist = "weibull") {
  call <- paste0("p", dist)
  avgerrors <- do.call(call, list(bnds$hband, bet, tht))
  avgerrors <- avgerrors + 1e-12
  return(avgerrors)
}

# helper function to remove the oldest n engines every month
disaggregate_hbands <- function(bnds) {
  tmp <- c(rep(bnds$hband, times = bnds$amount))
  ins <- c(rep(bnds$inspi, times = bnds$amount))
  tot <- c(rep(bnds$htotal, times = bnds$amount))
  # changed the order of tot and ins to fix an unnoticed bug
  ret <- data.frame(tmp, 1, tot, ins)
  names(ret) <- names(bnds)
  attributes(ret) <- c(attributes(ret), simple = attributes(bnds)$simple)
  return(ret)
}

# yet another disaggregation function
disagg <- function(ssp, amounts) {
  c(rep(ssp, amounts))
}

# function to adjust entries of a table generated by `get_hbands()`
# this function is now deprecated
inspect_engines <- function(bnds, hmonthly, hinterval, ninspections = 4) {
  htotaltmp <- bnds$htotal + hmonthly
  inspitmp <- floor(htotaltmp / hinterval)
  check <- ((inspitmp > bnds$inspi) & (bnds$inspi < ninspections))
  bnds$hband[check] <- bnds$hband[check] + hmonthly - hinterval
  bnds$hband[!check] <- bnds$hband[!check] + hmonthly
  bnds$htotal <- htotaltmp
  bnds$inspi[check] <- bnds$inspi[check] + 1
  return(bnds)
}

# updated version of inspect_engines to allow for dynamic user inputs
inspect_engines_pod <- function(bnds, hmonthly, insmatrix) {
  # exception for empty fleet
  if (is.null(bnds)) {
    ret <- get_hbands(NULL, simple = TRUE, insmatrix)
    return(ret)
  }
  # exception for no rows
  if (dim(bnds)[1] == 0) {
    return(bnds)
  }
  # i <- nrow(insmatrix) is the amount of inspections
  # => check i times if the hours htotal crossed a threshold
  check <- logical(length = nrow(bnds))
  htotaltmp <- bnds$htotal + hmonthly
  for (i in 1:nrow(insmatrix)) {
    pod <- insmatrix[i, 2]
    # only reset hours if the TOTAL hours have crossed the threshold
    # and if the current inspection interval is less than or equal than the
    # total number of inspections
    tmp <- ((bnds$htotal < insmatrix[i, 1]) & (htotaltmp >= insmatrix[i, 1]) & (bnds$inspi <= nrow(insmatrix)))
    # get indices of the engines that crossed an inspection threshold
    index <- which(tmp)
    # set those entries to FALSE with a probability of 1-POD to reflect the
    # possibility of not finding a possible early failure
    tmp[index] <- sample(c(T, F), length(index), replace = TRUE, prob = c(pod, 1 - pod))
    # set all hour values where errors were found through inspection to
    # #### This is not correct yet
    bnds$hband[tmp] <- 0 + htotaltmp[tmp] - insmatrix[i, 1]
    check <- check | tmp
  }
  bnds$hband[!check] <- bnds$hband[!check] + hmonthly
  # set all total values to the aged total value
  bnds$htotal <- htotaltmp
  # update the inspection interval count
  bnds$inspi <- get_intervals(bnds$htotal, insmatrix)
  return(bnds)
}

# function to generate age vector for monthly influx added to fleet
gen_age <- function(age = 0, distr = c("none"), draws, neg.default = 0, elps = list()) {
  if (distr == "none") {
    ret <- rep.int(age, times = as.integer(draws))
  } else {
    call <- paste("r", distr, sep = "")
    forms <- formals(call)
    check <- names(elps) %in% names(forms)
    args <- elps[check]
    ret <- do.call(call, list(draws, unlist(args)))
    ret <- round(ret)
    # exception handling might be needed to avoid negative ages entering through random draws
    if (sum(ret < 0) != 0) {
      warning(paste0(
        "Negative ages generated. Coercing to ", neg.default,
        ". Check documentation of `gen_age()`."
      ))
      check <- ret < 0
      ret[check] <- neg.default
    }
  }
  return(ret)
}

# remove oldest engines from fleet
# deprecated
rem_oldest <- function(bnds, amnt = 10, total = TRUE) {
  if (amnt == 0) {
    return(bnds)
  }
  if (attributes(bnds)$simple == FALSE) {
    bnds <- disaggregate_hbands(bnds)
  }
  if (total) {
    ret <- sort.data.frame(bnds, by = "htotal")
    ret <- head(ret, n = -amnt)
  } else {
    ret <- sort.data.frame(bnds, by = "hband")
    ret <- head(ret, n = -amnt)
  }
  return(ret)
}

# function to "age" the fleet without removing engines to get the correct delta error
# deprecated
age_fleet <- function(bnds, hrs) {
  ret <- bnds
  ret$hband <- ret$hband + hrs
  ret$htotal <- ret$htotal + hrs
  return(ret)
}

# function to generate the diagnostic line plot
plt_errors <- function(df) {
  mlt <- reshape2::melt(df, id.vars = "month")
  names(mlt) <- c("Month", "Errors", "value")
  plt1 <- ggplot(subset(mlt, Errors %in% "Cumulative"), aes(x = Month, y = value)) +
    geom_line(size = 1.25, col = "red") +
    geom_point(color = "black") +
    ggtitle("Errors: Cumulative") +
    ylab("Errors") +
    xlab("Months") +
    theme(
      plot.subtitle = element_text(vjust = 1),
      plot.caption = element_text(vjust = 1),
      axis.title = element_text(size = 12, face = "bold"),
      plot.title = element_text(size = 14, face = "bold"),
      panel.background = element_rect(fill = "aliceblue"),
      panel.grid.major = element_line(colour = "black"),
      panel.grid.minor = element_line(colour = "black")
    )
  plt2 <- ggplot(subset(mlt, Errors %in% "Monthly"), aes(x = Month, y = value)) +
    geom_line(size = 1.25, col = "blue") +
    geom_point(color = "black") +
    ggtitle("Errors: Monthly") +
    ylab("Errors") +
    xlab("Months") +
    theme(
      plot.subtitle = element_text(vjust = 1),
      plot.caption = element_text(vjust = 1),
      axis.title = element_text(size = 12, face = "bold"),
      plot.title = element_text(size = 14, face = "bold"),
      panel.background = element_rect(fill = "aliceblue"),
      panel.grid.major = element_line(colour = "black"),
      panel.grid.minor = element_line(colour = "black")
    )
  return(list(total = plt1, monthly = plt2))
}

# function to plot the error and mean data; df needs to be in structure as returned by simulation
plt_errors_bounds <- function(df) {
  names(df) <- c("Month", "Upper", "Lower", "Mean")
  mlt <- reshape2::melt(df, id.vars = "Month")
  names(mlt) <- c("Month", "Estimate", "Value")
  # reorder factor so the legend matches the sequence in the plot
  mlt$Estimate <- factor(mlt$Estimate, levels = c("Upper", "Mean", "Lower"), labels = c("Upper", "Mean", "Lower"))
  plt <- ggplot(mlt, aes(x = Month, y = Value, group = Estimate, color = Estimate)) +
    geom_line(size = 1) +
    scale_color_manual(values = c("#d00000", "#0000d0", "#00d000")) +
    theme_bw() +
    ggtitle("Upper and Lower Bounds of Expected Events") +
    labs(subtitle = "Evaluated at 95% Confidence Values of Characteristic Life")
  return(plt)
}

# function to generate weights for sampling of removed engines
gen_smp_weights <- function(ssp, rem = NULL, density = TRUE, type = c("dnorm", "pnorm", "dunif", "punif", "beta"), alpha = 1, beta = 1) {
  # handle case when there is only one or no more engines in the fleet
  if (length(ssp) <= 1) {
    return(NULL)
  }
  # weigh according to empirical density or ecdf of of known removal data
  if (!is.null(rem)) {
    dens <- density(scale(rem))
    scaledsus <- scale(ssp)
    scaledsus[scaledsus < min(dens$x)] <- min(dens$x)
    scaledsus[scaledsus > max(dens$x)] <- max(dens$x)
    dfun <- approxfun(dens)
    fun <- function(a) {
      integrate(dfun, lower = min(dens$x), upper = a)
    }
    if (density == TRUE) {
      tmp <- lapply(scaledsus, FUN = dfun)
    } else {
      tmp <- lapply(scaledsus, FUN = fun)
    }
    weights <- unlist(lapply(tmp, `[[`, 1))
  } else {
    # weigh according to specified distributions
    weights <- switch(type,
                      "dnorm" = {
                        dnorm(scale(ssp))
                      },
                      "pnorm" = {
                        pnorm(scale(ssp))
                      },
                      "dunif" = {
                        dunif(scales::rescale(ssp, to = c(0, 1)))
                      },
                      "punif" = {
                        punif(scales::rescale(ssp, to = c(0, 1)))
                      },
                      "beta" = {
                        dbeta(scales::rescale(ssp, to = c(0.01, 0.99)), alpha, beta)
                      },
                      {
                        print("default")
                      }
    )
  }
  # add tiny number to weights to avoid 0 output as sampling weight
  weights <- weights + 1e-5
  # sampling without replacement throws an error if there are weights equal to 0
  return(weights)
}

# function to remove a weighted sample from suspension data
remove_sample <- function(bnds, amnt, wgts) {
  if (amnt <= 0 | is.na(amnt)) {
    return(bnds)
  }
  if (nrow(bnds) == 0 | is.null(wgts)) {
    return(bnds)
    # this exception should not happen but is still here for legacy reasons
  } else if (nrow(bnds) != length(wgts)) {
    return(bnds)
  } else {
    smp <- sample(bnds$hband, size = amnt, replace = FALSE, prob = wgts)
    unq <- unique(smp)
    tmp <- bnds
    while (length(unq) > 0) {
      # updated to handle bnds objects like god intended
      tmp <- tmp[-match(unq, tmp$hband), ]
      smp <- smp[-match(unq, smp)]
      unq <- unique(smp)
    }
    return(tmp)
  }
}

# dataprocessing for removal amounts vector
prep_amounts <- function(ssp, removalamnts, nmonths, doremoval = TRUE) {
  if (doremoval == FALSE) {
    ret <- numeric(length = nmonths)
    return(ret)
  }
  # add trailing zeroes for months where no removal is wanted
  if (nmonths > length(removalamnts)) {
    ret <- numeric(length = nmonths)
    ret[1:length(removalamnts)] <- removalamnts
    return(ret)
  } else {
    ret <- removalamnts
    if (sum(removalamnts) > length(ssp)) {
      warning("More removals than Suspensions; consider adding monthly influx.")
    }
  }
  return(ret)
}

# wrapper to streamline removal process
remove_engines <- function(bnds, rem, density = T, type, amnt, insmatrix, betaalpha = 1, betabeta = 1) {
  # try and handle an exception raised by multimode multiruns
  if (is.null(bnds)) {
    return(bnds)
  }
  if (is.na(amnt > nrow(bnds))) {
    return(bnds)
  }
  if (amnt > nrow(bnds)) {
    amnt <- nrow(bnds)
  }
  weights <- gen_smp_weights(bnds$hband, rem, density, type, alpha = betaalpha, beta = betabeta)
  ret <- remove_sample(bnds, amnt, weights)
  return(ret)
}

# function to plot the concurrent fleet counts
plt_fleet <- function(fleetcount) {
  x <- 1:length(fleetcount)
  df <- data.frame(Month = x, Fleetcount = fleetcount)
  plt <- ggplot(df, aes(x = Month, y = Fleetcount)) +
    geom_point()
  return(plt)
}

# function to plot the monthly relative errors
plt_relerrors <- function(mrel) {
  x <- 1:length(mrel)
  df <- data.frame(Month = x, mrel = mrel)
  plt <- ggplot(df, aes(x = Month, y = mrel)) +
    geom_point() +
    xlab("Month") +
    ylab("Relative Error") +
    ggtitle("Monthly relative Errors")
  return(plt)
}

# wrapper to avoid bloating get_hbands even further
get_intervals <- function(hbands, insmatrix) {
  tmp <- insmatrix[, 1]
  intervalvect <- calc_interv_amnts(hbands, tmp)
  ret <- calc_interv_vect(hbands, intervalvect)
  return(ret)
}

# recursively calculating the amounts of engines in each inspection intervall
calc_interv_amnts <- function(vect, checkagainst) {
  ret <- numeric()
  if (length(checkagainst) == 1) {
    ret <- sum(floor(vect / checkagainst) == 0)
    return(ret)
  } else {
    tmp <- sum(floor(vect / checkagainst[1]) == 0)
    ret <- c(tmp, Recall(vect[-1:-tmp], checkagainst[-1]))
    return(ret)
  }
}

# generating the vector with the correct inspection interval numbers
calc_interv_vect <- function(vect, intervalvect) {
  inters <- 1:length(intervalvect)
  ret <- rep(inters, times = intervalvect)
  # exception in case there are no intervals; may not be needed; check later
  if (length(ret) == 0) {
    # if length(ret) == 0 can only be true if the total age of every engine
    # is larger than every inspection interval e.g. if no more inspections are
    # to be carried out. Thus set the returned vector to the maximum amount of
    # inspections (length(intervalvect)) + 1. So the condition in
    # `inspect_engines_pod` for the current inspection interval being less than
    # or equal than the total number of inspections is FALSE by default and no
    # more inspections are done.
    ret <- rep((length(intervalvect) + 1), times = length(vect))
    return(ret)
  } else {
    # bandaidfix in case times returns negative value
    tms <- length(vect) - length(ret)
    if (tms < 0) {
      tms <- 0
    }
    ret <- c(ret, rep((length(intervalvect) + 1), times = tms))
    return(ret)
  }
}

# preparing the amount vector for influx calculations
prep_influxvector <- function(influxamounts, nmonths, doinflux = T) {
  if (doinflux == F) {
    ret <- numeric(length = nmonths)
  } else if (nmonths > length(influxamounts)) {
    # add trailing zeroes to handle months where no more influx is wanted
    ret <- numeric(length = nmonths)
    ret[1:length(influxamounts)] <- influxamounts
  } else {
    ret <- influxamounts[1:nmonths]
  }
  return(ret)
}

# wrapper to return age vector that can be used by `get_hbands`
get_influx_age <- function(amnt, meth, elps = list()) {
  meth <- tolower(meth)
  # amount might be able to go negative
  if (amnt <= 0) {
    return(NULL)
  } else {
    ret <- switch(meth,
                  "constant" = {
                    # just return a predefined, constant age
                    rep(elps$age, times = amnt)
                  },
                  "prior" = {
                    # sample from prior kernel density estimate
                    sample_prior_kde(elps$influxprior, amnt)
                  },
                  {
                    gen_age_influx(distr = meth, amnt = amnt, elps)
                  }
    )
  }
  return(ret)
}

# recursive function to handle default case for switch in get_influx_age
gen_age_influx <- function(distr, amnt, elps = list()) {
  # build a call to flexibly sample from desired distributions
  call <- paste0("r", tolower(distr))
  forms <- formals(call)
  check <- names(elps) %in% names(forms)
  args <- elps[check]
  # list processing magic to get the structure needed for `do.call`
  tmp <- c(n = amnt, sapply(args, `[[`, 1))
  lst <- lapply(split(tmp, names(tmp)), unname)
  # generate age values based on specified call and argumentlist
  ret <- do.call(call, lst)
  ret <- round(ret)
  if (all(ret >= 0)) {
    return(ret)
  } else {
    # recursively change negative values to positive values sampled form the same distribution
    warning("Negative values generated in `gen_age_influx`. Consider recursionlimit.")
    ret <- c(ret[ret >= 0], Recall(distr, length(ret[ret < 0]), elps))
    return(ret)
  }
}

# recursive function to return age vector that can be digested by get_hbands
sample_prior_kde <- function(influxprior, amount) {
  if (length(influxprior) < 2) {
    return(0)
  }
  # get bandwidth and means to sample from kernel density estimate
  bw <- density(influxprior)$bw
  means <- sample(influxprior, 1000, replace = T)
  smp <- round(rnorm(amount, mean = means, sd = bw))
  if (all(smp >= 0)) {
    return(smp)
  } else {
    # recursively change negative values to positive values sampled from the same kde.
    ret <- c(smp[smp >= 0], Recall(influxprior, length(smp[smp < 0])))
    return(ret)
  }
}

# modified version of add_influx to finally add the correct bnds object
add_influx <- function(bnds, agevector, insmatrix) {
  if (is.null(agevector)) {
    return(bnds)
  } else {
    tmp <- get_hbands(sort(agevector), simple = attributes(bnds)$simple, insmatrix)
    ret <- rbind(tmp, bnds)
    # sorting by htotal because we cannot calculate the correct amount of engines
    # in each inspection interval any other way.
    ret <- sort.data.frame(ret, by = "htotal")
    # check aggregation for nonsimple case
  }
  return(ret)
}

# function to return a list of formals that can be processed by gen_age_influx
get_formals <- function(meth) {
  if (meth == "Constant" | meth == "Prior") {
    return(NULL)
  }
  call <- paste0("r", tolower(meth))
  # n argument is defined by amount given by user
  forms <- formals(call)[2:length(formals(call))]
  numberinputs <- length(forms)
  elps <- list()
  for (i in 1:numberinputs) {
    # nonstandard evaluation because we dynamically generate influxformal UI
    # elements based on userinput.
    elps[[i]] <- eval.parent(parse(text = paste0("input$influxformal", i)), n = 1)
  }
  names(elps) <- names(forms)
  return(elps)
}

# copy of a function in WeibullR that is not exported
ExtractContoursFromObjects <- function(x) {
  CP <- list()
  for (obj in 1:length(x)) {
    objCP <- getContoursFromSingleObject(x[[obj]])
    if (obj == 1) {
      for (li in 1:length(objCP)) {
        CP[[li]] <- objCP[[li]]
      }
    } else {
      if (names(CP[[length(CP)]]$contour[1]) != names(objCP[[1]]$contour[1])) {
        stop("dist mismatch in contours from objects")
      }
      cp_num <- length(CP)
      for (li in 1:length(objCP)) {
        cp_num <- cp_num + 1
        CP[[cp_num]] <- objCP[[li]]
      }
    }
  }
  
  CP
}

contourRange <- function(contour) {
  ra <- contour
  data.frame(range(ra[, 1]), range(ra[, 2]))
}


findContourRanges <- function(cplist) {
  findrange <- function(cp) {
    contourRange(cp$contour)
  }
  do.call("rbind", lapply(cplist, findrange))
}

ExtractContourParamsFromObject <- function(wblr) {
  str_eval <- function(x) {
    return(eval(parse(text = x)))
  }
  getParam <- function(par_name) {
    val <- NULL
    if (!is.null(str_eval(paste0("conf$options$", par_name)))) {
      val <- str_eval(paste0("conf$options$", par_name))
    } else {
      if (!is.null(str_eval(paste0("fit$options$", par_name)))) {
        val <- str_eval(paste0("fit$options$", par_name))
      } else {
        if (!is.null(str_eval(paste0("wblr$options$", par_name)))) {
          val <- str_eval(paste0("wblr$options$", par_name))
        }
      }
    }
    val
  }
  
  # no fit exists, so get param from base object options only, perhaps defaults
  getParam3 <- function(par_name) {
    val <- NULL
    if (!is.null(str_eval(paste0("wblr$options$", par_name)))) {
      val <- str_eval(paste0("wblr$options$", par_name))
    }
    val
  }
  
  
  if (!is.null(wblr$fit)) {
    ## a fit list exists
    for (fit_num in 1:length(wblr$fit)) {
      fit <- wblr$fit[[fit_num]]
      if (!is.null(fit$conf)) {
        for (conf_num in 1:length(fit$conf)) {
          conf <- fit$conf[[conf_num]]
          if (!is.null(conf$contour)) {
            ## Yeah!, we found a contour, get parameters from here seeking back toward
            ## base object options list if necessary.
            dist <- getParam("dist")
            dof <- getParam("dof")
            col <- getParam("col")
            lty <- getParam("lty")
            lwd <- getParam("lwd")
          } else {
            # a conf exists, but not a contour, so get the params from base object options
            # for some reason extraction getParam2 did not work here, did not want to debug further
            dist <- getParam3("dist")
            dof <- getParam3("dof")
            col <- getParam3("col")
            lty <- getParam3("lty")
            lwd <- getParam3("lwd")
          }
        }
      } else {
        # a fit exists, but get the params from base object options
        # for some reason extraction getParam2 did not work here, did not want to debug further
        dist <- getParam3("dist")
        dof <- getParam3("dof")
        col <- getParam3("col")
        lty <- getParam3("lty")
        lwd <- getParam3("lwd")
      }
    }
  } else {
    # no fit exists, get the params from base object options
    dist <- getParam3("dist")
    dof <- getParam3("dof")
    col <- getParam3("col")
    lty <- getParam3("lty")
    lwd <- getParam3("lwd")
  }
  
  outlist <- NULL
  if (exists("dist")) {
    outlist <- list(dist = dist, dof = dof, col = col, lty = lty, lwd = lwd)
  }
  outlist
}

CalculateContours <- function(x, CL) {
  c2p <- list()
  wblr_num <- 0
  while (wblr_num < length(x)) {
    wblr_num <- wblr_num + 1
    params <- ExtractContourParamsFromObject(x[[wblr_num]])
    # warn and drop any 3p suffix from params$dist
    # this should never happen because 3p distribution specification should only appear in wblr.fit, not wblr
    # there would be no conf in the 3p fit, so only base wblr dist option would be returned here
    # but lets just avoid this strange case.
    if (substr(params$dist, nchar(params$dist) - 1, nchar(params$dist)) == "3p") {
      params$dist <- substr(params$dist, 1, nchar(params$dist) - 2)
      warning("3p dist modification specified in wblr has been ignored")
    }
    
    # test for dist mismatch here
    if (wblr_num > 1) {
      if (c2p[[length(c2p)]]$dist != params$dist) {
        stop("dist mismatch in entered objects")
      }
    }
    fit <- unname(mlefit(x[[wblr_num]]$data$lrq_frame, dist = params$dist))
    
    for (cl_num in 1:length(CL)) {
      ## ptDensity could be a function of CL[cl_num]
      ## 360 for CL=.9, 40 for CL=.1
      dens <- ceiling(360 * CL[cl_num] / .9)
      
      if (wblr_num == 1 && cl_num == 1) {
        c2p_num <- 1
      } else {
        c2p_num <- length(c2p) + 1
      }
      ## usage MLEcontour(x,  dist="weibull", CL=0.9,dof=1,MLEfit=NULL, RadLimit=1e-5,
      ## 		ptDensity=120, debias="none", show=FALSE)  {
      c2p[[c2p_num]] <- list()
      c2p[[c2p_num]]$contour <- MLEcontour(
        x[[wblr_num]]$data$lrq_frame,
        dist = params$dist,
        CL = CL[cl_num],
        dof = params$dof,
        MLEfit = fit,
        ptDensity = dens
      )
      c2p[[c2p_num]]$dist <- params$dist
      c2p[[c2p_num]]$MLEpt <- fit
      c2p[[c2p_num]]$color <- params$col
      # check implementation of ExtractParamsFromObject here
      c2p[[c2p_num]]$lty <- params$lty
      c2p[[c2p_num]]$lwd <- params$lwd
    }
  }
  c2p
}

getContoursFromSingleObject <- function(wblr) {
  FOUND <- FALSE
  
  if (!is.null(wblr$fit)) {
    ## a fit list exists
    
    for (fit_num in 1:length(wblr$fit)) {
      fit <- wblr$fit[[fit_num]]
      if (!is.null(fit$conf)) {
        for (conf_num in 1:length(fit$conf)) {
          conf <- fit$conf[[conf_num]]
          if (!is.null(conf$contour)) {
            ## Yeah!, we found a contour
            # 						if(!exists("CP")) {
            # use of exists("CP") became problematic when CP indeed existed outside of function environment
            if (!FOUND) {
              FOUND <- TRUE
              CP <- list()
              j <- 1
              CP[[j]] <- list()
            } else {
              
              ## here is the place to confirm fit types
              if (names(CP[[length(CP)]]$MLEpt[1]) != names(fit$MLEfit[1])) {
                warning("contours of mixed fit type found, mismatch ignored")
                break
              }
              
              j <- length(CP) + 1
              CP[[j]] <- list
            }
            
            CP[[j]]$contour <- conf$contour
            CP[[j]]$dist <- wblr$options$dist
            CP[[j]]$MLEpt <- fit$MLEfit[-3]
            if (!is.null(conf$options$lty)) {
              CP[[j]]$lty <- conf$options$lty
            } else {
              if (!is.null(fit$options$lty)) {
                CP[[j]]$lty <- fit$options$lty
              } else {
                CP[[j]]$lty <- wblr$options$lty
              }
            }
            if (!is.null(conf$options$lwd)) {
              CP[[j]]$lwd <- conf$options$lwd
            } else {
              if (!is.null(fit$options$lwd)) {
                CP[[j]]$lwd <- fit$options$lwd
              } else {
                CP[[j]]$lwd <- wblr$options$lwd
              }
            }
            if (!is.null(conf$options$col)) {
              CP[[j]]$color <- conf$options$col
            } else {
              if (!is.null(fit$options$col)) {
                CP[[j]]$color <- fit$options$col
              } else {
                CP[[j]]$color <- wblr$options$col
              }
            }
          }
        }
      }
    }
  }
  if (!exists("CP")) {
    stop("no contour found in listed object, try adding CL argument to calculate")
  }
  CP
}

plot_default_args <- function() {
  paronly <- c(
    "ask", "fig", "fin", "lheight", "mai", "mar", "mex", "mfcol",
    "mfrow", "mfg", "new", "oma", "omd", "omi", "pin", "plt", "ps", "pty",
    "usr", "xlog", "ylog", "ylbias"
  )
  # parameters that can only be set using par()
  # see $par() for the origin of this list
  parreadonly <- c(
    "xlog", "ylog", "adj", "ann", "ask",
    "bg", "bty", "cex", "cex.axis", "cex.lab",
    "cex.main", "cex.sub", "col", "col.axis", "col.lab",
    "col.main", "col.sub", "crt", "err", "family",
    "fg", "fig", "fin", "font", "font.axis",
    "font.lab", "font.main", "font.sub", "lab", "las",
    "lend", "lheight", "ljoin", "lmitre", "lty",
    "lwd", "mai", "mar", "mex", "mfcol",
    "mfg", "mfrow", "mgp", "mkh", "new",
    "oma", "omd", "omi", "pch", "pin",
    "plt", "ps", "pty", "smo", "srt",
    "tck", "tcl", "usr", "xaxp", "xaxs",
    "xaxt", "xpd", "yaxp", "yaxs", "yaxt",
    "ylbias"
  )
  # par() parameter that can be set
  # par(no.readonly=TRUE)
  parplot <- unique(sort(c(
    parreadonly[!(parreadonly %in% paronly)],
    "type", "xlim", "ylim", "log", "main", "sub", "xlab", "ylab",
    "ann", "axes", "frame.plot", "panel.first", "panel.last", "asp"
  )))
  # all valid (?) graphical parameters that can be supplied
  # to plot.default
  parplot
}


# function to plot weibayes ridge
plt_weibayesridge <- function(failures, suspensions) {
  # contour.wblr requires an object of class wblr so we create an aggregated table of the
  # suspension data
  fdf <- as.data.frame(table(failures))
  ft <- as.numeric(levels(fdf[, 1]))
  fq <- fdf[, 2]
  sdf <- as.data.frame(table(suspensions))
  st <- as.numeric(levels(sdf[, 1]))
  sq <- sdf[, 2]
  fail_edata <- data.frame(time = ft, event = rep(1, length(ft)), qty = fq)
  sus_edata <- data.frame(time = st, event = rep(0, length(st)), qty = sq)
  teq_frame <- rbind(fail_edata, sus_edata)
  # contour plot
  x <- wblr(teq_frame)
  arg <- list(col = "darkgrey")
  opa <- x[[1]]$options
  CL <- seq(.1, .9, by = .1)
  if (!is.null(CL)) {
    if (class(CL) == "wblr") stop("multiple wblr objects must be entered as a list")
  }
  if (identical(class(x), "wblr")) x <- list(x)
  if (!all(sapply(x, function(x) identical(class(x), "wblr")))) {
    stop(
      "Argument \"x\" is not of class \"wblr\" or ",
      "a list of \"wblr\" objects."
    )
  }
  if (is.null(CL)) {
    C2P <- ExtractContoursFromObjects(x)
  } else {
    C2P <- CalculateContours(x, CL)
  }
  if (names(C2P[[1]]$contour)[1] == "Mulog" && AL == TRUE) {
    for (C2Pli in 1:length(C2P)) {
      C2P[[C2Pli]]$contour <- exp(C2P[[C2Pli]]$contour)
    }
    names(C2P[[1]]$contour) <- c("MuAL", "SigAL")
  }
  contourRanges <- findContourRanges(C2P)
  if (!is.null(contourRanges)) {
    xlimits <- range(contourRanges[, 1])
    ylimits <- range(contourRanges[, 2])
    opanames <- names(opa)
    plotargs <- c(
      list(x = NA, axes = TRUE),
      opa[opanames %in% plot_default_args()]
    )
    plotargs$xlim <- xlimits
    plotargs$ylim <- ylimits
    
    plotargs$main <- opa$main.contour
    plotargs$sub <- opa$sub.contour
    plotargs$log <- ""
    plotargs$xlab <- names(C2P[[1]]$contour)[1]
    plotargs$ylab <- names(C2P[[1]]$contour)[2]
    plotargs$main <- opa$main.contour
    ## overrides from the dots
    if (!is.null(arg$xlim)) plotargs$xlim <- arg$xlim
    if (!is.null(arg$ylim)) plotargs$ylim <- arg$ylim
    if (is.null(arg$main)) plotargs$main <- arg$main
    if (is.null(arg$sub)) plotargs$sub <- arg$sub
    do.call("plot.default", plotargs)
    abline(
      h = pretty(contourRanges[, 2], 10),
      v = pretty(contourRanges[, 1], 10),
      col = "grey"
    )
  }
  for (cntr in 1:length(C2P)) {
    
    # plot MLE points always a black 'x' symbol
    points(
      x = C2P[[cntr]]$MLEpt[1], y = C2P[[cntr]]$MLEpt[2],
      # 			pch=opa$options$pch,
      pch = 4,
      # col=C2P[[cntr]]$color,
      # col=opa$col,
      col = "black",
      lwd = opa$lwd.points,
      cex = opa$cex.points
    )
    # browser()
    lwd <- C2P[[cntr]]$lwd
    lty <- C2P[[cntr]]$lty
    col <- C2P[[cntr]]$color
    ## overrides from the dots
    if (!is.null(arg$lwd)) lwd <- arg$lwd
    if (!is.null(arg$lty)) lty <- arg$lty
    if (!is.null(arg$col)) col <- arg$col
    # browser()
    # plot the contours
    points(C2P[[cntr]]$contour, type = "l", lwd = lwd, lty = lty, col = col)
  }
  beta_range <- seq(0, 10, by = 0.1)
  # adding points along ridge of the estimate
  wbpts <- NULL
  for (b in beta_range) {
    eta <- weibayesfix(teq_frame, beta = b)
    this_pt <- c(eta, b)
    wbpts <- rbind(wbpts, this_pt)
  }
  points(wbpts, pch = 3, col = "blue")
  title(main = "Ridge of the Weibayes Estimate")
  p <- recordPlot()
  return(p)
}

# function to plot the results of multiple runs
plt_multiruns <- function(data, meth) {
  dtalong <- reshape2::melt(data)
  plt <- ggplot(data = dtalong, aes(x = Var1, y = value, group = Var2)) +
    ggtitle("Monthly Expected Events for Runs") +
    xlab("Months") +
    ylab("Events") +
    if (meth == "point") {
      geom_point(alpha = 0.1)
    } else {
      geom_violin(aes(x = Var1, y = value, group = Var1))
    }
  return(plt)
}

# function to plot the results of multiple runs for a single month of interest
plt_singlemonth <- function(data, month) {
  plt <- ggplot(data = reshape2::melt(data[month, ]), aes(x = value)) +
    geom_density() +
    xlab("Events") +
    ylab("Density") +
    ggtitle(paste0("KDE of events in month ", month))
  return(plt)
}

weibull_curve <- function(expr, from = NULL, to = NULL, n = 101, add = FALSE,
                          type = "l", xname = "x", xlab = xname, ylab = NULL, log = NULL,
                          xlim = NULL, ...) {
  sexpr <- substitute(expr)
  if (is.name(sexpr)) {
    expr <- call(as.character(sexpr), as.name(xname))
  }
  else {
    expr <- sexpr
  }
  x <- seq.int(from, to, length.out = n)
  
  ll <- list(x = x)
  names(ll) <- xname
  y <- eval(expr, envir = ll, enclos = parent.frame())
  if (length(y) != length(x)) {
    stop("'expr' did not evaluate to an object of length 'n'")
  }
  list(x = x, y = y)
}

# function needed for conversion of probability values between 0 and 1 to y
# values digestible by the weibull canvas
p2y <- function(p, canvas = "weibull") {
  if (canvas == "weibull") {
    ret <- log(qweibull(p, 1, 1))
  }
  if (canvas == "lognormal") {
    ret <- qlnorm(p, 0, 1)
  }
  ret
}

# old version from version 1.0.10 of WeibullR
p2y_old <- function(p, log = "x") {
  if (log == "x") ret <- log(qweibull(p, 1, 1))
  if (log == "xy") ret <- qlnorm(p, 0, 1)
  ret
}

# recursive function to obtain product of all list entries
# that thing is beautiful as a motherfucker
listproduct <- function(input) {
  if (length(input) == 1) {
    return(input[[1]])
  }
  input[[1]] * Recall(input[-1])
}

# function to return system unreliability
get_system_unrel <- function(params = list()) {
  curves <- list()
  # reliability values are given by pweibull(params) at the specified time
  for (i in seq_along(params$beta)) {
    curves[[i]] <- weibull_curve(
      pweibull(
        x - params[["t0"]][i], params[["beta"]][i], params[["eta"]][[i]]
      ),
      n = 20001, from = 0, to = 5e+05
    )
  }
  # convert unreliability values to reliability values
  rels <- list()
  for (i in seq_along(params$beta)) {
    rels[[i]] <- 1 - curves[[i]]$y
    rels[[i]][rels[[i]] < 0] <- 0
  }
  # figure out system reliability by getting the listproduct and transform back
  # to the unreliability scale
  sysunrel <- 1 - listproduct(rels)
  xseq <- seq(from = 0, to = 5e+5, length.out = 20001)
  list(x = xseq, y = sysunrel)
}

# function to find absolute maximum and minimum range over the list of wblr objects
findMaxDataRange <- function(x, log = "") {
  findrange <- function(wblr) {
    if (!is.null(wblr$data)) {
      alltimes <- c(wblr$data$dpoints$time, wblr$data$dlines$t1[wblr$data$dlines$t1 > 0], wblr$data$dlines$t2)
      if (!is.null(alltimes)) {
        ret <- data.frame(xrange = range(alltimes))
      } else {
        stop("no time data, cannot create plot canvas.")
      }
      allppp <- c(wblr$data$dpoints$ppp, wblr$data$dlines$ppp)
      if (!is.null(allppp)) {
        ret <- cbind(ret, yrange = range(allppp))
      } else {
        stop(
          "$data$dpoints or $dlines contains no ppp -> ",
          "cannot create plot canvas."
        )
      }
    } else {
      stop('Argument \"x\" contains no \"$data \" list object.')
    }
    ret
  }
  if (all(sapply(x, function(x) identical(class(x), "wblr")))) {
    ret <- do.call("rbind", lapply(x, findrange))
  } else {
    stop("Argument \"x\" is no list of \"wblr\" objects.")
  }
  if (tolower(log) %in% c("x", "xy", "yx")) {
    ret[ret$xrange <= 0, 1] <- NA
  }
  ret
}

# function needed to plot neat looking canvas
plot_default_args <- function() {
  paronly <- c(
    "ask", "fig", "fin", "lheight", "mai", "mar", "mex", "mfcol",
    "mfrow", "mfg", "new", "oma", "omd", "omi", "pin", "plt", "ps", "pty",
    "usr", "xlog", "ylog", "ylbias"
  )
  parreadonly <- c(
    "xlog", "ylog", "adj", "ann", "ask",
    "bg", "bty", "cex", "cex.axis", "cex.lab",
    "cex.main", "cex.sub", "col", "col.axis", "col.lab",
    "col.main", "col.sub", "crt", "err", "family",
    "fg", "fig", "fin", "font", "font.axis",
    "font.lab", "font.main", "font.sub", "lab", "las",
    "lend", "lheight", "ljoin", "lmitre", "lty",
    "lwd", "mai", "mar", "mex", "mfcol",
    "mfg", "mfrow", "mgp", "mkh", "new",
    "oma", "omd", "omi", "pch", "pin",
    "plt", "ps", "pty", "smo", "srt",
    "tck", "tcl", "usr", "xaxp", "xaxs",
    "xaxt", "xpd", "yaxp", "yaxs", "yaxt",
    "ylbias"
  )
  parplot <- unique(sort(c(
    parreadonly[!(parreadonly %in% paronly)],
    "type", "xlim", "ylim", "log", "main", "sub", "xlab", "ylab",
    "ann", "axes", "frame.plot", "panel.first", "panel.last", "asp"
  )))
  parplot
}

# functions to get grid lines for weibull and lognormal canvas
seq.wb <- function(from, to, base = seq(1, 9, 1)) {
  # define gridline positions for 'Median Rank' axis (= y axis)
  r <- c(seq.log(from, .9, base), rev(1 - seq.log(1 - to, 0.1, base))[-1])
  r[r >= from & r <= to]
}

seq.log <- function(from, to, base = c(1, 2, 5)) {
  r <- NULL
  for (i in floor(log10(from)):floor(log10(to))) r <- c(r, base * 10^i)
  r[r >= from & r <= to]
}

# function to generate a neat looking weibull canvas
plotweibullcanvas <- function(x, ...) {
  if (identical(class(x), "wblr")) {
    x <- list(x)
  }
  if (!all(sapply(x, function(x) identical(class(x), "wblr")))) {
    stop(
      "Argument \"x\" is not of class \"wblr\" or ",
      "a list of \"wblr\" objects."
    )
  }
  arg <- list(...)
  if (!is.null(arg$log)) {
    warning("log option is to be depreciated in favor of canvas")
    if (arg$log == "xy" || arg$log == "yx") {
      arg$canvas <- "lognormal"
      arg$log <- "xy"
    }
    else {
      if (arg$log == "x") {
        arg$canvas <- "weibull"
      }
      else {
        stop("if used, log argument must be \"x\", \"xy\", or \"yx\" ")
      }
    }
  }
  else {
    if (!is.null(arg$canvas)) {
      if (tolower(arg$canvas) == "lognormal") {
        arg$log <- "xy"
      }
      else {
        arg$log <- "x"
        if (tolower(arg$canvas) != "weibull") {
          warning("canvas option not recognized, default \"weibull\" is assumed")
          arg$canvas <- "weibull"
        }
      }
    }
  }
  opa <- x[[1]]$options
  opa <- modifyList(opa, arg)
  dotargs <- arg
  ra <- findMaxDataRange(x, opa$log)
  xlimits <- range(ra$xrange, na.rm = TRUE)
  ylimits <- range(ra$yrange, na.rm = TRUE)
  if (is.null(opa$xlim)) {
    opa$xlim <- c(10^(log10(xlimits[1]) - 0.5), 10^(log10(xlimits[2]) +
                                                      1))
  }
  if (is.null(opa$ylim)) {
    if (ylimits[1] < 0.01) {
      opa$ylim <- c(signif(ylimits[1], 1), 0.99)
    } else {
      opa$ylim <- c(0.01, 0.99)
    }
  }
  opanames <- names(opa)
  plotargs <- c(list(x = NA, axes = FALSE), opa[opanames %in% plot_default_args()])
  if (!is.null(plotargs$ylim)) {
    plotargs$ylim <- p2y_old(plotargs$ylim, opa$log)
  }
  plotargs$main <- NULL
  if (!is.null(opa$mar)) {
    par(mar = opa$mar)
  }
  if (!is.null(opa$mai)) {
    par(mai = opa$mai)
  }
  do.call(plot.default, plotargs)
  if (opa$is.plot.grid) {
    abline(h = p2y_old(
      seq.wb(opa$ylim[1] / 10, 1 - (1 - opa$ylim[2]) / 10),
      opa$log
    ), v = seq.log(opa$xlim[1] / 10, opa$xlim[2] *
                     10, seq(0, 10, 1)), col = opa$col.grid)
  }
  r <- seq.log(opa$xlim[1] / 10, opa$xlim[2] * 10, c(1, 5))
  for (t in c(1, 3)) {
    axis(t, at = seq.log(
      opa$xlim[1] / 10, opa$xlim[2] * 10,
      seq(0, 10, 0.2)
    ), labels = NA, tcl = -0.25)
    axis(t, at = r, labels = r, tcl = -0.75)
  }
  r <- c(seq.wb(
    opa$ylim[1] / 10, 1 - (1 - opa$ylim[2]) / 10,
    c(1, 2, 5)
  ), 0.9)
  for (t in c(2, 4)) {
    axis(t, at = p2y_old(
      seq.wb(opa$ylim[1] / 10, 1 - (1 - opa$ylim[2]) / 10),
      opa$log
    ), labels = NA, tcl = -0.25)
    axis(t, at = p2y_old(r, opa$log), labels = r * 100, tcl = -0.75)
  }
  abline(h = 0, lty = 3, col = opa$col.grid)
  title(main = opa$main, line = 3)
  invisible()
}

# file input module
csvFileInput <- function(id, label = "CSV file") {
  # Create a namespace function using the provided id
  ns <- NS(id)
  # all input or output IDs of any kind need to be wrapped in a call to ns()
  # wrap everything in a tagList to return multiple UI elements
  tagList(
    fileInput(ns("file"), label),
    checkboxInput(ns("IDyesno"), "First column ID?", value = FALSE),
    selectInput(ns("inputSeparator"), "Separator",
                selected = ";",
                choices = c(";", ",")
    )
  )
}

# Module server function
csvFile <- function(input, output, session, stringsAsFactors) {
  userFile <- reactive({
    # If no file is selected, don't do anything
    # for future reference: shiny::validate is masked by jsonlite::validate
    shiny::validate(need(input$file, message = FALSE))
    input$file
  })
  
  # parse file to data frame
  dataframe <- reactive({
    dta <- read.csv(userFile()$datapath,
                    header = FALSE,
                    stringsAsFactors = FALSE,
                    sep = input$inputSeparator
    )
    if (ncol(dta) < 2) {
      colnames(dta) <- `if`(input$IDyesno, c("Hours"), c("Hours"))
    } else {
      colnames(dta) <- `if`(input$IDyesno, c("ID", "Hours"), c("Hours", "ID"))
    }
    list(inputdata = dta)
  })
  
  # verify file upload
  observe({
    msg <- sprintf("File %s was uploaded", userFile()$name)
    cat(msg, "\n")
  })
  # return the list that contains the dataframe object
  return(dataframe)
}

# general file input module
csvFileInputGeneral <- function(id, label = "CSV file") {
  ns <- NS(id)
  tagList(
    fileInput(ns("file"), label)
  )
}

# general file upload server function module
csvFileGeneral <- function(input, output, session, stringsAsFactors) {
  userFile <- reactive({
    input$file
  })
  dataframe <- reactive({
    if (is.null(userFile()$datapath)) {
      return(NULL)
    }
    dta <- read.csv(userFile()$datapath,
                    header = FALSE,
                    stringsAsFactors = FALSE
    )
    list(inputdata = dta)
  })
  observe({
    msg <- sprintf("File %s was uploaded", userFile()$name)
    cat(msg, "\n")
  })
  return(dataframe)
}

# special file upload server function module for weirdevents type csv files
csvFileWeird <- function(input, output, session, stringsAsFactors) {
  userFile <- reactive({
    input$file
  })
  dataframe <- reactive({
    if (is.null(userFile()$datapath)) {
      return(NULL)
    }
    dta <- readr::read_csv(userFile()$datapath,
                           skip = 2
    )
    list(inputdata = dta)
  })
  observe({
    msg <- sprintf("File %s was uploaded", userFile()$name)
    cat(msg, "\n")
  })
  return(dataframe)
}

get_risk <- function(fleet, minmonth, maxage, influx, x, y, fleetrisk, cycles) {
  for (i in seq_len(minmonth)) {
    # perform agecheck
    fleet <- agecheck(fleet, maxage)
    # correct influx vector
    if (length(influx) < minmonth) {
      influx <- c(influx, rep(0, times = minmonth - length(influx)))
    }
    # calc fleet risk
    if ((is.null(x) | is.null(y))) {
      fleetrisk[i] <- 0
    } else {
      fleetrisk[i] <- sum(approx(x, y, xout = fleet)$y)
    }
    # add influx to fleet
    fleet <- c(rep(0, times = influx[i]), fleet)
    # age the fleet by the desired cycles
    fleet <- fleet + cycles
  }
  fleetrisk
}

# helper function for quick age check
agecheck <- function(fleet, maxage) {
  fleet[fleet < maxage]
}

get_risks <- function(fleetdata, influxdata, maxage, cycles, riskdata) {
  # fleetdata: list containing all the fleet cycle values
  # influxdata: list containing all the influxdata
  # maxage: list or vector containing the specified maximum ages for all fleets
  # cycles: list or vector containing the cycles per discrete time step for all fleets
  # riskdata: list containing the risk data for each fleet
  # step 1: get minmonths
  minmonths <- map2(maxage, cycles, `/`)
  minmonths <- map(minmonths, ceiling)
  # step 2: initialize fleetrisk vectors
  fleetrisks <- map(minmonths, numeric)
  # step 3: initialize x and y for interpolation later on
  # naming is inconsistent with the actual data represented in the data frame => TODO
  x <- map(riskdata, `$`, cycles)
  y <- map(riskdata, `$`, pe)
  
  # step 4: apply all parts of the loop over fleet entries
  fleetrisks <- pmap(list(fleetdata, minmonths, maxage, influxdata, x, y, fleetrisks, cycles), get_risk)
  return(fleetrisks)
}

plt_weirdevents <- function(mlt) {
  agg <- aggregate(mlt$value, by = list(res = mlt$variable), FUN = sum)
  check <- agg$x[agg$res == "fleet2"]
  if (check != 0) {
    plt <- ggplot(mlt, aes(x = time, y = value, colour = variable)) +
      geom_line() +
      ggtitle("Expected Events") +
      xlab("Discrete Time Steps") +
      ylab("Events") +
      scale_color_hue(labels = c("Fleet 1", "Fleet 2", "Sum"), name = "")
  } else {
    tmp <- mlt[mlt$variable == "fleet1", ]
    plt <- ggplot(tmp, aes(x = time, y = value, colour = variable)) +
      geom_line() +
      ggtitle("Expected Events") +
      xlab("Discrete Time Steps") +
      ylab("Events") +
      scale_color_hue(labels = c("Fleet 1"), name = "")
  }
  plt
}

colMax <- function(data) sapply(data, max, na.rm = TRUE)

#### Shiny Modules and utilities needed for a dynamic UI that allows filtering of xlsx inputs ====
# ui module to construct filter UI
filterDF_UI <- function(id, show_nrow = TRUE) {
  # set namespace needed for shiny module
  ns <- NS(id)
  # set taglist for ui element
  tagList(
    # wrap contents (tags) that should be included in the underlying generated
    # HTML only once, yet may appear in the document generating code more than
    # once. Only the first appearance of the content will be used.
    singleton(
      tags$style(
        ".selectize-big .selectize-input {height: 72px; overflow-y: scroll;}"
      )
    ),
    if (isTRUE(show_nrow)) uiOutput(outputId = ns("nrow")),
    tags$div(id = ns("placeholder-filters"))
  )
}

# server module equivalent needed for filterDF_UI
filterDF <- function(input, output, session,
                     data_table = reactive(),
                     data_vars = shiny::reactive(NULL),
                     data_name = reactive("data"),
                     label_nrow = "Number of rows:",
                     drop_ids = FALSE,
                     picker = FALSE) {
  ns <- session$ns
  jns <- function(x) paste0("#", ns(x))
  
  output$nrow <- renderUI({
    if (!is.null(label_nrow)) {
      tags$p(label_nrow, tags$b(nrow(data_filtered()), "/", nrow(data_table())))
    }
  })
  
  rv_filters <- reactiveValues(mapping = NULL, mapping_na = NULL)
  rv_code <- reactiveValues(expr = NULL, dplyr = NULL)
  
  observe({
    data <- data_table()
    vars <- data_vars()
    removeUI(selector = jns("filters_inputs"), immediate = TRUE)
    filters <- create_filters(
      data = data, vars = vars,
      drop_ids = drop_ids, picker = picker
    )
    insertUI(
      selector = jns("placeholder-filters"),
      ui = tags$div(
        id = ns("filters_inputs"),
        filters$ui
      ),
      immediate = TRUE
    )
    rv_filters$mapping <- filters$filters_id
    rv_filters$mapping_na <- filters$filters_na_id
  })
  
  data_filtered <- reactive({
    data <- data_table()
    req(all(names(rv_filters$mapping) %in% names(data)))
    filter_inputs <- lapply(
      X = rv_filters$mapping,
      FUN = function(x) {
        input[[x]]
      }
    )
    filter_nas <- lapply(
      X = rv_filters$mapping_na,
      FUN = function(x) {
        input[[x]]
      }
    )
    filters <- make_expr_filter(
      filters = filter_inputs,
      filters_na = filter_nas,
      data = data,
      data_name = isolate(data_name())
    )
    rv_code$expr <- filters$expr
    rv_code$dplyr <- filters$expr_dplyr
    if (length(rv_code$expr) > 0) {
      result <- eval_tidy(expr = rv_code$expr, data = data)
      data[result, ]
    } else {
      data
    }
  })
  
  list(
    data_filtered = data_filtered,
    code = rv_code
  )
}

# Utils ====
# create filters based on data input
create_filters <- function(data, vars = NULL,
                           drop_ids = TRUE,
                           picker = FALSE,
                           width = "100%", session = getDefaultReactiveDomain()) {
  ns <- session$ns
  data <- drop_na(data)
  if (isTRUE(drop_ids)) {
    data <- drop_id(data)
  }
  data <- dropListColumns(data)
  if (is.null(vars)) {
    vars <- names(data)
  } else {
    vars <- intersect(names(data), vars)
  }
  
  filters_id <- paste0("filter_", clean_string(vars))
  filters_id <- setNames(as.list(filters_id), vars)
  filters_na_id <- setNames(as.list(paste0("na_", filters_id)), vars)
  # construct ui to be returned as a list through the use of lapply
  ui <- lapply(
    X = vars,
    # "inline" function to construct UI
    FUN = function(variable) {
      var <- data[[variable]]
      any_na <- anyNA(var)
      var <- var[!is.na(var)]
      id <- filters_id[[variable]]
      tag_label <- if (any_na) {
        tags$span(
          tags$label(variable), HTML("&nbsp;&nbsp;"),
          na_filter(id = ns(paste0("na_", id)))
        )
      } else {
        tags$span(tags$label(variable), HTML("&nbsp;&nbsp;"))
      }
      # numeric inputs
      if (inherits(x = var, what = c("numeric", "integer"))) {
        params <- find_range_step(var)
        tags$div(
          style = "position: relative;",
          tag_label,
          set_slider_attr(sliderInput(
            inputId = ns(id),
            min = params$min,
            max = params$max,
            width = width,
            value = params$range,
            step = params$step,
            label = NULL
          ))
        )
        # date inputs
      } else if (inherits(x = var, what = c("Date", "POSIXct"))) {
        range_var <- range(var)
        tags$div(
          style = "position: relative;",
          tag_label,
          set_slider_attr(sliderInput(
            inputId = ns(id),
            min = min(var),
            max = max(var),
            width = width,
            value = range(var),
            label = NULL
          ))
        )
      } else {
        # character inputs
        values <- unique(as.character(var))
        values <- values[trimws(values) != ""]
        if (isTRUE(picker)) {
          tags$div(
            style = "position: relative;",
            tag_label,
            pickerInput(
              inputId = ns(id),
              choices = values,
              selected = values,
              label = NULL,
              multiple = TRUE,
              width = width,
              options = pickerOptions(
                actionsBox = TRUE,
                selectedTextFormat = "count",
                liveSearch = TRUE
              )
            )
          )
        } else {
          tags$div(
            style = "position: relative;",
            class = if (length(values) > 15) "selectize-big",
            tag_label,
            selectizeInput(
              inputId = ns(id),
              choices = values,
              selected = values,
              label = NULL,
              multiple = TRUE,
              width = width,
              options = list(plugins = list("remove_button"))
            )
          )
        }
      }
    }
  )
  list(
    ui = tagList(ui),
    filters_id = filters_id,
    filters_na_id = filters_na_id
  )
}

# helper function to set tag attributes
tagSetAttributes <- function(tag, ...) {
  tag$attribs[names(list(...))] <- NULL
  tag$attribs <- c(tag$attribs, list(...))
  tag
}

# helper function to set slider attributes
set_slider_attr <- function(slider) {
  slider$children[[2]] <- tagSetAttributes(
    tag = slider$children[[2]],
    `data-force-edges` = "true",
    `data-grid-num` = "4"
  )
  slider
}

# na switch to filter NA values out of data frame
na_filter <- function(id) {
  tags$span(
    style = "position: absolute; right: 0px; margin-right: -20px;",
    prettySwitch(
      inputId = id,
      label = "NA",
      value = TRUE,
      slim = TRUE,
      status = "primary",
      inline = TRUE
    )
  )
}

# black magic fuckery to construct dplyr and base R calls according to chosen filter criteria
# read the rlang reference manual for more information regarding `!!`, `sym` and `expr`
make_expr_filter <- function(filters, filters_na, data, data_name) {
  expressions <- lapply(
    X = names(filters),
    FUN = function(var) {
      values <- filters[[var]]
      nas <- filters_na[[var]]
      data_values <- data[[var]]
      if (!is.null(values) & !match_class(values, data_values)) {
        return(NULL)
      }
      values_expr <- NULL
      if (inherits(x = values, what = c("numeric", "integer"))) {
        data_range <- find_range_step(data_values)$range
        if (!isTRUE(all.equal(values, data_range))) {
          if (isTRUE(nas)) {
            if (anyNA(data_values)) {
              values_expr <- expr(!!sym(var) >= !!values[1] & !!sym(var) <= !!values[2] | is.na(!!sym(var)))
            } else {
              values_expr <- expr(!!sym(var) >= !!values[1] & !!sym(var) <= !!values[2])
            }
          } else {
            if (anyNA(data_values)) {
              values_expr <- expr(!!sym(var) >= !!values[1] & !!sym(var) <= !!values[2] & !is.na(!!sym(var)))
            } else {
              values_expr <- expr(!!sym(var) >= !!values[1] & !!sym(var) <= !!values[2])
            }
          }
        }
      } else if (inherits(x = values, what = c("Date", "POSIXct"))) {
        values <- format(values)
        data_range <- range(data_values, na.rm = TRUE)
        data_range <- format(data_range)
        if (!identical(values, data_range)) {
          if (isTRUE(nas)) {
            if (anyNA(data_values)) {
              values_expr <- expr(!!sym(var) >= !!values[1] & !!sym(var) <= !!values[2] | is.na(!!sym(var)))
            } else {
              values_expr <- expr(!!sym(var) >= !!values[1] & !!sym(var) <= !!values[2])
            }
          } else {
            if (anyNA(data_values)) {
              values_expr <- expr(!!sym(var) >= !!values[1] & !!sym(var) <= !!values[2] & !is.na(!!sym(var)))
            } else {
              values_expr <- expr(!!sym(var) >= !!values[1] & !!sym(var) <= !!values[2])
            }
          }
        }
      } else {
        data_values <- unique(as.character(data_values))
        if (!identical(sort(values), sort(data_values))) {
          if (length(values) == 0) {
            if (isTRUE(nas)) {
              values_expr <- expr(is.na(!!sym(var)))
            } else {
              values_expr <- expr(!(!!sym(var) %in% !!data_values[!is.na(data_values)]) & !is.na(!!sym(var)))
            }
          } else {
            if (length(values) <= length(data_values) / 2) {
              if (isTRUE(nas)) {
                if (anyNA(data_values)) {
                  values_expr <- expr(!!sym(var) %in% !!values | is.na(!!sym(var)))
                } else {
                  values_expr <- expr(!!sym(var) %in% !!values)
                }
              } else {
                values_expr <- expr(!!sym(var) %in% !!values)
              }
            } else {
              if (isTRUE(nas)) {
                if (anyNA(data_values)) {
                  values_expr <- expr(!(!!sym(var) %in% !!setdiff(data_values[!is.na(data_values)], values)) | is.na(!!sym(var)))
                } else {
                  values_expr <- expr(!(!!sym(var) %in% !!setdiff(data_values[!is.na(data_values)], values)))
                }
              } else {
                if (anyNA(data_values)) {
                  values_expr <- expr(!(!!sym(var) %in% !!setdiff(data_values[!is.na(data_values)], values)) & !is.na(!!sym(var)))
                } else {
                  values_expr <- expr(!(!!sym(var) %in% !!setdiff(data_values[!is.na(data_values)], values)))
                }
              }
            }
          }
        }
      }
      if (is.null(values_expr) & !isTRUE(nas) & anyNA(data_values)) {
        expr(!is.na(!!sym(var)))
      } else {
        values_expr
      }
    }
  )
  expressions <- dropNullsOrEmpty(expressions)
  expr_dplyr <- Reduce(
    f = function(x, y) expr(!!x %>% filter(!!y)),
    x = expressions,
    init = expr(!!sym(data_name))
  )
  expression <- Reduce(
    f = function(x, y) expr(!!x & !!y),
    x = expressions
  )
  return(list(
    expr_dplyr = expr_dplyr,
    expr = expression
  ))
}

# helper function to drop factor and character IDs
drop_id <- function(data) {
  data[] <- lapply(
    X = data,
    FUN = function(x) {
      if (inherits(x, c("factor", "character"))) {
        values <- unique(as.character(x))
        # trim whitespace
        values <- values[trimws(values) != ""]
        if (length(values) <= 1) {
          return(NULL)
        }
        if (length(values) >= length(x) * 0.9) {
          return(NULL)
        }
        if (length(values) >= 50) {
          return(NULL)
        }
      }
      x
    }
  )
  data
}

# function to drop NAs
drop_na <- function(data) {
  data[] <- lapply(
    X = data,
    FUN = function(x) {
      if (all(is.na(x))) {
        return(NULL)
      }
      x
    }
  )
  data
}

# function to find out if number has decimal point or not
hasDecimals <- function(value) {
  truncatedValue <- round(value)
  return(!identical(value, truncatedValue))
}

# function to find optimal steps for UI elements
find_range_step <- function(x) {
  max <- max(x, na.rm = TRUE)
  min <- min(x, na.rm = TRUE)
  range <- max - min
  if (range < 2 || hasDecimals(min) || hasDecimals(max)) {
    pretty_steps <- pretty(c(min, max), n = 100, high.u.bias = 1)
    n_steps <- length(pretty_steps) - 1
    list(
      range = range(pretty_steps),
      min = min(pretty_steps),
      max = max(pretty_steps),
      step = signif(digits = 10, (max(pretty_steps) - min(pretty_steps)) / n_steps)
    )
  }
  else {
    list(
      range = range(x, na.rm = TRUE),
      min = min,
      max = max,
      step = 1
    )
  }
}

# wrapper to match classes
match_class <- function(x, y) {
  char <- c("character", "factor")
  num <- c("numeric", "integer")
  date <- c("Date", "POSIXt")
  if (inherits(x, num) & inherits(y, num)) {
    return(TRUE)
  }
  if (inherits(x, char) & inherits(y, char)) {
    return(TRUE)
  }
  if (inherits(x, date) & inherits(y, date)) {
    return(TRUE)
  }
  return(FALSE)
}

# fancy or
`%||%` <- function(a, b) {
  if (!is.null(a)) a else b
}

# fancy comparator
`%empty%` <- function(a, b) {
  if (a != "") a else b
}

# fancy comparator
`%|e|%` <- function(a, b) {
  if (!is.null(a) && a != "") a else b
}

# base::Negate wrapper for %in%
`%nin%` <- Negate(`%in%`)

# helper function from the esquisse package
list1 <- function(x) {
  if (is.null(x)) {
    return(x)
  }
  if (length(x) == 1 & !is.list(x)) {
    list(x)
  } else {
    x
  }
}

# helper function from the esquisse package
dropNulls <- function(x) {
  x[!vapply(x, is.null, FUN.VALUE = logical(1))]
}

# helper function from the esquisse package
nullOrEmpty <- function(x) {
  is.null(x) || length(x) == 0 || x == ""
}

# helper function from the esquisse package
dropNullsOrEmpty <- function(x) {
  x[!vapply(x, nullOrEmpty, FUN.VALUE = logical(1))]
}

# helper function from the esquisse package
clean_string <- function(str) {
  str <- stri_trans_general(str = str, id = "Latin-ASCII")
  str <- stri_trans_tolower(str)
  str <- make.unique(str)
  str <- stri_replace_all_regex(str = str, pattern = "[^a-zA-Z0-9_]+", replacement = "_")
  return(str)
}

# helper function from the esquisse package
get_df <- function(df, env = globalenv()) {
  if (df %in% ls(name = env)) {
    get(x = df, envir = env)
  } else if (df %in% data(package = "ggplot2", envir = environment())$results[, "Item"]) {
    get(utils::data(list = df, package = "ggplot2", envir = environment()))
  } else {
    NULL
  }
}

# helper function from the esquisse package
search_obj <- function(what = "data.frame", env = globalenv()) {
  all <- ls(name = env)
  objs <- lapply(
    X = all,
    FUN = function(x) {
      if (inherits(get(x, envir = env), what = what)) {
        x
      } else {
        NULL
      }
    }
  )
  objs <- unlist(objs)
  if (length(objs) == 1 && objs == "") {
    NULL
  } else {
    objs
  }
}

# helper function from the esquisse package
badgeType <- function(col_name, col_type) {
  stopifnot(length(col_name) == length(col_type))
  res <- lapply(
    X = seq_along(col_name),
    FUN = function(i) {
      col_name_i <- col_name[i]
      col_type_i <- col_type[i]
      if (col_type_i == "discrete") {
        tags$span(class = "label label-discrete badge-dad", col_name_i)
      } else if (col_type_i == "time") {
        tags$span(class = "label label-datetime badge-dad", col_name_i)
      } else if (col_type_i == "continuous") {
        tags$span(class = "label label-continue badge-dad", col_name_i)
      } else if (col_type_i == "id") {
        tags$span(class = "label label-default badge-dad", col_name_i)
      }
    }
  )
  res
}

# helper function from the esquisse package
col_type <- function(x, no_id = FALSE) {
  if (is.null(x)) {
    return(NULL)
  }
  
  if (is.data.frame(x) && inherits(x, what = "sf")) {
    x <- x[, setdiff(names(x), attr(x, "sf_column")), drop = FALSE]
  }
  
  if (is.data.frame(x)) {
    return(unlist(lapply(x, col_type), use.names = FALSE))
  } else {
    if (inherits(x, c("logical", "character", "factor", "AsIs"))) {
      n <- length(x)
      u <- length(unique(x))
      if (u / n < 0.99 | u <= 30 | no_id) {
        return("discrete")
      } else {
        return("id")
      }
    }
    
    if (inherits(x, c("Date", "POSIXct", "POSIXlt"))) {
      return("time")
    }
    
    if (inherits(x, c("numeric", "integer", "double"))) {
      return("continuous")
    }
  }
  
  NULL
}

# helper function from the esquisse package
geomIcons <- function() {
  geoms <- c(
    "auto", "line", "area", "bar", "histogram",
    "point", "boxplot", "violin", "density",
    "tile", "sf"
  )
  href <- "esquisse/geomIcon/gg-%s.png"
  geomsChoices <- lapply(
    X = geoms,
    FUN = function(x) {
      list(inputId = x, img = sprintf(fmt = href, x), label = capitalize(x))
    }
  )
  
  geomsChoicesNames <- lapply(
    X = geomsChoices,
    FUN = function(x) {
      list(
        style = "width: 90px;",
        tags$img(src = x$img, width = 56, height = 56),
        tags$br(), x$label
      )
    }
  )
  geomsChoicesValues <- unlist(lapply(geomsChoices, `[[`, "label"), use.names = FALSE)
  geomsChoicesValues <- tolower(geomsChoicesValues)
  
  list(names = geomsChoicesNames, values = geomsChoicesValues)
}

# helper function from the esquisse package
capitalize <- function(x) {
  lo <- substring(text = x, first = 2)
  up <- substring(text = x, first = 1, last = 1)
  lo <- tolower(lo)
  up <- toupper(up)
  lo <- gsub(pattern = "_", replacement = " ", x = lo)
  paste0(up, lo)
}

# helper function from the esquisse package
dropListColumns <- function(x) {
  type_col <- vapply(X = x, FUN = typeof, FUN.VALUE = character(1), USE.NAMES = FALSE)
  x[, type_col != "list", drop = FALSE]
}

col2Hex <- function(col) {
  mat <- grDevices::col2rgb(col, alpha = TRUE)
  grDevices::rgb(mat[1, ] / 255, mat[2, ] / 255, mat[3, ] / 255)
}

# helper function from the esquisse package
linear_gradient <- function(cols) {
  x <- round(seq(from = 0, to = 100, length.out = length(cols) + 1))
  ind <- c(1, rep(seq_along(x)[-c(1, length(x))], each = 2), length(x))
  m <- matrix(data = paste0(x[ind], "%"), ncol = 2, byrow = TRUE)
  res <- lapply(
    X = seq_len(nrow(m)),
    FUN = function(i) {
      paste(paste(cols[i], m[i, 1]), paste(cols[i], m[i, 2]), sep = ", ")
    }
  )
  res <- unlist(res)
  res <- paste(res, collapse = ", ")
  paste0("linear-gradient(to right, ", res, ");")
}

# helper function from the esquisse package
normalizeChoicesArgs <- function(choices, choiceNames, choiceValues, mustExist = TRUE) {
  if (is.null(choices)) {
    if (is.null(choiceNames) || is.null(choiceValues)) {
      if (mustExist) {
        stop(
          "Please specify a non-empty vector for `choices` (or, ",
          "alternatively, for both `choiceNames` AND `choiceValues`)."
        )
      }
      else {
        if (is.null(choiceNames) && is.null(choiceValues)) {
          return(list(choiceNames = NULL, choiceValues = NULL))
        }
        else {
          stop(
            "One of `choiceNames` or `choiceValues` was set to ",
            "NULL, but either both or none should be NULL."
          )
        }
      }
    }
    if (length(choiceNames) != length(choiceValues)) {
      stop("`choiceNames` and `choiceValues` must have the same length.")
    }
    if (anyNamed(choiceNames) || anyNamed(choiceValues)) {
      stop("`choiceNames` and `choiceValues` must not be named.")
    }
  }
  else {
    if (!is.null(choiceNames) || !is.null(choiceValues)) {
      warning("Using `choices` argument; ignoring `choiceNames` and `choiceValues`.")
    }
    choices <- choicesWithNames(choices)
    choiceNames <- names(choices)
    choiceValues <- unname(choices)
  }
  return(list(choiceNames = as.list(choiceNames), choiceValues = as.list(as.character(choiceValues))))
}

# helper function from the esquisse package
choicesWithNames <- function(choices) {
  listify <- function(obj) {
    makeNamed <- function(x) {
      if (is.null(names(x))) {
        names(x) <- character(length(x))
      }
      x
    }
    res <- lapply(obj, function(val) {
      if (is.list(val)) {
        listify(val)
      } else if (length(val) == 1 && is.null(names(val))) {
        val
      } else {
        makeNamed(as.list(val))
      }
    })
    makeNamed(res)
  }
  choices <- listify(choices)
  if (length(choices) == 0) {
    return(choices)
  }
  choices <- mapply(choices, names(choices), FUN = function(choice,
                                                            name) {
    if (!is.list(choice)) {
      return(choice)
    }
    if (name == "") {
      stop("All sub-lists in \"choices\" must be named.")
    }
    choicesWithNames(choice)
  }, SIMPLIFY = FALSE)
  missing <- names(choices) == ""
  names(choices)[missing] <- as.character(choices)[missing]
  choices
}

# helper function from the esquisse package
anyNamed <- function(x) {
  if (length(x) == 0) {
    return(FALSE)
  }
  nms <- names(x)
  if (is.null(nms)) {
    return(FALSE)
  }
  any(nzchar(nms))
}

# file input module
csvFileInputReadr <- function(id, label = "CSV file") {
  # Create a namespace function using the provided id
  ns <- NS(id)
  # all input or output IDs of any kind need to be wrapped in a call to ns()
  # wrap everything in a tagList to return multiple UI elements
  tagList(
    fileInput(ns("file"), label)
  )
}

# Module server function
csvFileReadr <- function(input, output, session, stringsAsFactors) {
  userFile <- reactive({
    # If no file is selected, don't do anything
    # for future reference: shiny::validate is masked by jsonlite::validate
    shiny::validate(need(input$file, message = FALSE))
    input$file
  })
  
  # parse file to data frame
  dataframe <- reactive({
    dta <- read.xlsx(
      file = userFile()$datapath,
      sheetIndex = 1,
      stringsAsFactors = FALSE
    )
    dta[is.na(dta)] <- 0
    dta <- read.xlsx(
      file = userFile()$datapath,
      sheetIndex = 1,
      stringsAsFactors = FALSE
    )
    list(inputdata = dta)
  })
  
  # verify file upload
  observe({
    msg <- sprintf("File %s was uploaded", userFile()$name)
    cat(msg, "\n")
  })
  # return the list that contains the dataframe object
  return(dataframe)
}

# recursively drawing from normal distribution to allow for truncated draws
truncated_rnorm <- function(n, mean, sd, min, max, maxdepth = 1000) {
  res <- rnorm(n, mean, sd)
  if ((sum(res <= min) == 0) & (sum(res > max) == 0)) {
    return(res)
  } else {
    nn <- length(res[res < min | res > max])
    if (rlang::trace_length(rlang::trace_back()) >= maxdepth) {
      warning("Truncating present, consider recursion limit.")
    }
    res[res < min | res > max] <- truncated_rnorm(nn, mean, sd, min, max)
    return(res)
  }
}

# wrapper to simulate fleets seeded with initial crack sizes
crack_simulation <- function(crack_fun = "-2520 * log(x) + 6614.4", crack_n_intervals = 200,
                             crack_intervalsize = 100, crack_fleet = purrr::rdunif(100, 1, 1),
                             crack_proportion = c(1, 1, 0), crack_means = c(0.16, 0.97060, 2.4),
                             crack_sds = c(0.08, 0.05444, 0.08), crack_mins = c(0, 0, 0),
                             crack_maxs = c(0.4, Inf, Inf), crack_nruns = 100) {
  crack_dta <- data.frame(fleet = crack_fleet)
  # initialize proportion matrix
  crack_proportions <- matrix(0, nrow = crack_n_intervals, ncol = crack_nruns)
  
  for (j in seq_len(crack_nruns)) {
    # do the sampling for every run in here
    # multinorm sample
    crack_dta$fleet <- crack_fleet
    crack_tmp <- rmultinom(1, nrow(crack_dta), crack_proportion)
    crack_dta$mode <- c(
      rep(1, times = crack_tmp[1, 1]),
      rep(2, times = crack_tmp[2, 1]),
      rep(3, times = crack_tmp[3, 1])
    )
    # reshuffle to avoid sorting bias
    crack_dta$mode <- sample(crack_dta$mode, replace = FALSE)
    crack_dta$init <- 0
    # calculate the proportions for every run in here
    for (i in seq_len(crack_n_intervals)) {
      crack_dta$init[crack_dta$mode == i] <- truncated_rnorm(
        n = length(crack_dta$init[crack_dta$mode == i]),
        mean = crack_means[i],
        sd = crack_sds[i],
        min = crack_mins[i],
        max = crack_maxs[i]
      )
      # evaluate max lyf on that shiet
      crack_envi <- new.env()
      crack_envi$x <- crack_dta$init
      crack_call <- rlang::parse_expr(crack_fun)
      crack_dta$maxlife <- rlang::eval_tidy(crack_call, env = crack_envi)
      crack_dta$faulty <- crack_dta$maxlife <= crack_dta$fleet
      crack_dta$fleet <- crack_dta$fleet + crack_intervalsize
      crack_proportions[i, j] <- sum(crack_dta$faulty) / nrow(crack_dta)
    }
  }
  colnames(crack_proportions) <- as.character(1:ncol(crack_proportions))
  crackprop_fds <- rainbow::fds(y = crack_proportions, x = 1:nrow(crack_proportions))
  # wrap in if clause; return mean and maxima minima based on selection criterion
  tmp <- data.frame(y = crackprop_fds$y, x = crackprop_fds$x)
  ret <- data.frame(y = crackprop_fds$y)
  avg <- rowMeans(ret)
  if (crack_nruns > 10) {
    nms <- colnames(ret)[apply(ret, 1, which.max)]
    maxi <- unique(nms)
    nms <- colnames(ret)[apply(ret, 1, which.min)]
    mini <- unique(nms)
    extrema <- unique(c(maxi, mini))
    ret <- ret[, extrema, drop = FALSE]
    if (crack_nruns < 500) {
      # limit to the estimated boundary (see minimax_funcdata.R)
      ret <- ret[, 1:min(ncol(ret), floor(8 * log(crack_nruns))), drop = FALSE]
    }
    if (crack_nruns > 500) {
      # make sure we never return more than 50 columns
      ret <- ret[, 1:min(ncol(ret), 50), drop = FALSE]
    }
  }
  colnames(ret) <- 1:ncol(ret)
  ret$x <- crackprop_fds$x
  ret$mean <- avg
  mlt <- reshape2::melt(tmp, id = "x")
  ret$acchours <- ret$x * crack_intervalsize
  return(list(ret = ret, mlt = mlt))
}

# plot data.frames returned by `crack_simulation`
plt_fds <- function(data) {
  plt <- ggplot(data) +
    geom_line(aes(x = x, y = value, group = variable), col = "#0000ff", alpha = 0.3, inherit.aes = FALSE) +
    theme(legend.position = "none") +
    theme_bw() +
    xlab("Intervals") +
    ylab("Proportion of Failures") +
    ylim(c(0, 1)) +
    ggtitle(label = paste0("Proportion of Failures over ", " runs:"))
  return(plt)
}

# function to approximately find the proportions of failures by mode
get_proportions <- function(shapes, scales, n = 50000) {
  check <- (shapes > 0) & (scales > 0)
  if (sum(check) == 0) {
    warning("Invalid Shapes & Scales entered, defaulting to 1, 1.")
    shapes <- list(1)
    scales <- list(1)
  }
  # do sampling to find proportion of engines that succumb to the modes
  samples <- purrr::pmap(list(shapes, scales), rweibull, n = n)
  samples <- do.call(cbind, samples)
  # the minimum value corresponds to failing first
  mincol <- max.col(-samples)
  proportions <- as.data.frame.table(table(mincol))
  proportions$rel <- proportions$Freq / sum(proportions$Freq)
  proportions$names <- c("One", "Two", "Three")[1:nrow(proportions)]
  return(proportions)
}

# function to recursively sample from fleets based on proportions given by get_proportions
sample_fleets <- function(fleet, proportions) {
  # split fleet into proportional parts
  fleets <- list()
  tmp <- fleet
  # fill the list with proportional parts
  for (j in seq_len(nrow(proportions))) {
    # preserve original size to make sure we sample the whole fleet
    # round down to avoid larger sample size than original fleet
    samplesize <- floor(proportions$rel[j] * length(fleet))
    # reconversion for sample_frac
    fleets[[j]] <- sample_n(as.data.frame(tmp), size = samplesize)[, 1]
    sample <- fleets[[j]]
    unq <- unique(sample)
    # handle sampling like god intended
    while (length(unq) > 0) {
      tmp <- tmp[-match(unq, tmp)]
      sample <- sample[-match(unq, sample)]
      unq <- unique(sample)
    }
  }
  return(fleets)
}

# purrr equivalent of simulation() to process lists
mrmr_sim <- function(nruns, fleet, proportions, inspectionmatrix, shapes, scales,
                     efperiod = 0, maxlyf = Inf, hmonth, removaldist, removalmethod,
                     removaltype, removal_amounts, betaalpha, betabeta,
                     influxamountsvector, influxmethod, influxepls, simdist,
                     replacefaulty = FALSE, removefaulty = FALSE, nmonths, ...) {
  results <- list()
  for (i in seq_len(nruns)) {
    fleets <- sample_fleets(fleet, proportions)
    fleets <- purrr::map(fleets, sort)
    bnds <- purrr::map(fleets, get_hbands, inspectionmatrix = inspectionmatrix)
    monthly_errors <- list()
    for (j in seq_len(nmonths)) {
      bnds <- purrr::pmap(list(bnds = bnds, amnt = get_rem_amnts_lst(bnds, removal_amounts[j])),
                          remove_engines,
                          rem = removaldist, density = removalmethod,
                          type = removaltype, insmatrix = inspectionmatrix,
                          betaalpha = betaalpha, betabeta = betabeta
      )
      initial_errors <- purrr::pmap(list(bnds, as.list(shapes), as.list(scales)),
                                    calc_errors_fast,
                                    efperiod = efperiod, maxlyf = maxlyf
      )
      initial_errors$total <- do.call(sum, initial_errors)
      aged_fleet <- purrr::pmap(list(bnds), inspect_engines_pod,
                                hmonthly = hmonth,
                                insmatrix = inspectionmatrix
      )
      aged_errors <- purrr::pmap(list(aged_fleet, as.list(shapes), as.list(scales)),
                                 calc_errors_fast,
                                 efperiod = efperiod, maxlyf = maxlyf
      )
      aged_errors$total <- do.call(sum, aged_errors)
      monthly_errors[[j]] <- map2(aged_errors, initial_errors, `-`)
      bnds <- purrr::pmap(list(bnds), inspect_engines_pod,
                          hmonthly = hmonth,
                          insmatrix = inspectionmatrix
      )
      proportional_influx <- round(influxamountsvector[j] * proportions$rel)
      monthly_influx <- purrr::pmap(list(as.list(proportional_influx)), get_influx_age,
                                    meth = influxmethod, elps = influxepls
      )
      # finally add the influx to the list of fleets
      bnds <- purrr::pmap(list(bnds = bnds, agevector = monthly_influx), add_influx,
                          insmatrix = inspectionmatrix
      )
      
      if (removefaulty == TRUE) {
        faultyweights <- purrr::pmap(list(bnds = bnds, bet = shapes, tht = scales),
                                     get_dist_weights,
                                     dist = simdist
        )
        partial <- purrr::map(monthly_errors[[j]][1:(length(monthly_errors[[j]]) - 1)], round)
        bnds <- purrr::pmap(
          list(bnds = bnds, amnt = partial, wgts = faultyweights),
          remove_sample
        )
      }
      if (replacefaulty == TRUE) {
        partial <- purrr::map(monthly_errors[[j]][1:(length(monthly_errors[[j]]) - 1)], round)
        replacementages <- purrr::pmap(list(partial), get_influx_age, meth = "constant", elps = list(age = 0))
        bnds <- purrr::pmap(list(bnds = bnds, agevector = replacementages), add_influx,
                            insmatrix = inspectionmatrix
        )
      }
    }
    # get rid of one layer of nesting
    monthly_errors <- lapply(monthly_errors, unlist)
    results_i <- do.call(rbind, monthly_errors)
    colnames(results_i) <- c(1:(ncol(results_i) - 1), "total")
    # results now consists of a list with the individual results of every run.
    results[[i]] <- results_i
  }
  return(results)
}

# multimode multirun wrapper that returns a plot and a data frame
mm_simulation <- function(hmonth, errorfreeperiod, nmonths, failures, shapes, scales,
                          simdist = "weibull", simple = TRUE, suspensions, removaldist,
                          removalamnts, removalmethod, removaltype, removeyesno = TRUE,
                          removefaulty = FALSE, inspectionmatrix, doinflux, influxelps,
                          influxamounts, influxmethod, betaalpha, betabeta, replacefaulty,
                          maxlyf, nruns, ...) {
  # preprocess inputdata
  fleet <- sort(c(suspensions, failures, failures))
  # bnds <- get_hbands(fleet, simple, inspectionmatrix)
  # original_errors <- calc_errors_fast(bnds = bnds, tht = theta, bet = beta,
  #                                    efperiod = errorfreeperiod, dist = simdist, maxlyf = maxlyf)
  removal_amounts <- prep_amounts(fleet, removalamnts, nmonths, doremoval = removeyesno)
  influxamountsvector <- prep_influxvector(influxamounts, nmonths, doinflux)
  # preprocessing data necessary for multiruns
  proportions <- get_proportions(shapes, scales, n = 25000)
  # calculate results
  results <- mrmr_sim(
    nruns = nruns, fleet = fleet, proportions = proportions,
    inspectionmatrix = inspectionmatrix, shapes = shapes, scales = scales,
    efperiod = errorfreeperiod, maylyf = maxlyf, hmonth = hmonth,
    removaldist = removaldist, removalmethod = removalmethod,
    removal_amounts = removal_amounts, betaalpha = betaalpha,
    betabeta = betabeta, influxamountsvector = influxamountsvector,
    influxmethod = influxmethod, influxelps = influxelps, simdist = simdist,
    replacefaulty = replacefaulty, removefaulty = removefaulty,
    nmonths = nmonths, removaltype = removaltype
  )
  mlt <- reshape2::melt(results)
  # also wrap in plotting function to directly plot from the returned results list
  plt <- ggplot(data = mlt, aes(x = Var1, y = value, color = Var2, group = Var2)) +
    geom_line() +
    # stat_smooth() +
    ggtitle("Number of Events by Failuremode") +
    ylab("Events") +
    xlab("Months") +
    labs(color = "Modus") +
    theme_bw()
  return(list(plt = plt, mlt = mlt))
}

# function to evenly split the removal amounts based on the length of the list
get_rem_amnts_lst <- function(bnds, amnt) {
  fcnt <- sum(unlist(purrr::map(bnds, nrow)))
  prps <- purrr::map(purrr::map(bnds, nrow), `/`, fcnt)
  temp <- purrr::map(purrr::map(prps, `*`, amnt), round)
  return(temp)
}

# This function is used to create all the magrittr pipe operators.
pipe <- function() {
  function(lhs, rhs) {
    # the parent environment
    parent <- parent.frame()
    # the environment in which to evaluate pipeline
    env    <- new.env(parent = parent)
    # split the pipeline/chain into its parts.
    chain_parts <- split_chain(match.call(), env = env)
    pipes <- chain_parts[["pipes"]] # the pipe operators.
    rhss  <- chain_parts[["rhss" ]] # the right-hand sides.
    lhs   <- chain_parts[["lhs"  ]] # the left-hand side.
    # Create the list of functions defined by the right-hand sides.
    env[["_function_list"]] <-
      lapply(seq_along(rhss),
             function(i) wrap_function(rhss[[i]], pipes[[i]], parent))
    # Create a function which applies each of the above functions in turn.
    env[["_fseq"]] <-
      `class<-`(eval(quote(function(value) freduce(value, `_function_list`)),
                     env, env), c("fseq", "function"))
    # make freduce available to the resulting function
    # even if magrittr is not loaded.
    env[["freduce"]] <- freduce
    # Result depends on the left-hand side.
    if (is_placeholder(lhs)) {
      # return the function itself.
      env[["_fseq"]]
    } else {
      # evaluate the LHS
      env[["_lhs"]] <- eval(lhs, parent, parent)
      # compute the result by applying the function to the LHS
      result <- withVisible(eval(quote(`_fseq`(`_lhs`)), env, env))
      # If assignment pipe is used, assign result
      if (is_compound_pipe(pipes[[1L]])) {
        eval(call("<-", lhs, result[["value"]]), parent, parent)
        # Otherwise, return it.
      } else {
        if (result[["visible"]])
          result[["value"]]
        else
          invisible(result[["value"]])
      }
    }
  }
}

# Pipe an object forward into a function or call expression.
`%>%`  <- pipe()
